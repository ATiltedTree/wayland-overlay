From a0792111f4c4a9989d27efd2cfa807f1416f8899 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:28:21 +0300
Subject: [PATCH 013/147] winewayland.drv: Update Windows monitor information
 on Wayland changes.

Whenever the Wayland output display state changes (including during
initialization), update the monitor information on the Windows side to
reflect these changes. The update happens when handling output events
targeting the per-process Wayland instance.

We currently support a single GPU, and a single monitor for each
adapter.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   3 +-
 dlls/winewayland.drv/display.c         | 140 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c         |   2 +
 dlls/winewayland.drv/wayland_output.c  |   3 +
 dlls/winewayland.drv/waylanddrv.h      |   7 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 6 files changed, 155 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/display.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f1e1d1cc655..8ccbac45930 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = user32
+IMPORTS   = user32 win32u
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -10,6 +10,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
+	display.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..4b5d2c2449d
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,140 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winreg.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static BOOL force_display_devices_refresh;
+
+static void wayland_refresh_display_devices(void)
+{
+    UINT32 num_path, num_mode;
+    force_display_devices_refresh = TRUE;
+    /* trigger refresh in win32u */
+    NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
+}
+
+void wayland_init_display_devices()
+{
+    wayland_refresh_display_devices();
+}
+
+static void wayland_add_gpu(const struct gdi_device_manager *device_manager,
+                            void *param)
+{
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    struct gdi_gpu gpu = {0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    /* TODO: Fill in gpu information from vulkan. */
+
+    TRACE("id=0x%s name=%s\n",
+          wine_dbgstr_longlong(gpu.id), wine_dbgstr_w(gpu.name));
+
+    device_manager->add_gpu(&gpu, param);
+}
+
+static void wayland_add_adapter(const struct gdi_device_manager *device_manager,
+                                void *param, INT output_id)
+{
+    struct gdi_adapter adapter;
+    adapter.id = output_id;
+    adapter.state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
+    if (output_id == 0)
+        adapter.state_flags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    TRACE("id=0x%s state_flags=0x%x\n",
+          wine_dbgstr_longlong(adapter.id), adapter.state_flags);
+
+    device_manager->add_adapter(&adapter, param);
+}
+
+static void wayland_add_monitor(const struct gdi_device_manager *device_manager,
+                                void *param, struct wayland_output *output)
+{
+
+    struct gdi_monitor monitor = {0};
+
+    if (!MultiByteToWideChar(CP_UTF8, 0, output->name, -1, monitor.name,
+                             ARRAY_SIZE(monitor.name)))
+    {
+        monitor.name[0] = 0;
+    }
+
+    SetRect(&monitor.rc_monitor, output->x, output->y,
+            output->x + output->current_mode->width,
+            output->y + output->current_mode->height);
+
+    /* We don't have a direct way to get the work area in Wayland. */
+    monitor.rc_work = monitor.rc_monitor;
+
+    monitor.state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+
+    TRACE("name=%s rc_monitor=rc_work=%s state_flags=0x%x\n",
+          wine_dbgstr_w(monitor.name), wine_dbgstr_rect(&monitor.rc_monitor),
+          monitor.state_flags);
+
+    device_manager->add_monitor(&monitor, param);
+}
+
+/***********************************************************************
+ *      UpdateDisplayDevices (WAYLAND.@)
+ */
+void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                        BOOL force, void *param)
+{
+    struct wayland *wayland;
+    struct wayland_output *output;
+    INT output_id = 0;
+
+    if (!force && !force_display_devices_refresh) return;
+
+    TRACE("force=%d force_refresh=%d\n", force, force_display_devices_refresh);
+
+    force_display_devices_refresh = FALSE;
+
+    wayland = wayland_process_acquire();
+
+    wayland_add_gpu(device_manager, param);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_mode) continue;
+
+        /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+        wayland_add_adapter(device_manager, param, output_id);
+        wayland_add_monitor(device_manager, param, output);
+
+        output_id++;
+    }
+
+    wayland_process_release();
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1f5c966121a..64c041d6c1c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -94,6 +94,8 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
         {
             TRACE("removing output->name=%s\n", output->name);
             wayland_output_destroy(output);
+            if (wayland_is_process(wayland))
+                wayland_init_display_devices();
             return;
         }
     }
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 4b624ed7379..7fdee76bcd0 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -305,6 +305,9 @@ static void wayland_output_done(struct wayland_output *output)
               o->logical_x, output->logical_y, o->logical_w, o->logical_h,
               o->x, o->y, o->current_mode->width, o->current_mode->height);
     }
+
+    if (wayland_is_process(output->wayland))
+        wayland_init_display_devices();
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ab79c6b4a1e..661280da21a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,9 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h"
+
+#include "wine/gdi_driver.h"
 
 extern struct wl_display *process_wl_display;
 
@@ -108,6 +111,7 @@ void wayland_deinit(struct wayland *wayland);
 BOOL wayland_is_process(struct wayland *wayland);
 struct wayland *wayland_process_acquire(void);
 void wayland_process_release(void);
+void wayland_init_display_devices(void);
 
 /**********************************************************************
  *          Wayland output
@@ -122,6 +126,9 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
  */
 
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                               BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 249bf08cbfd..c26caa059b0 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -81,6 +81,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
+    .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
 };
 
-- 
2.34.1

