From 28ed2383e663b1f4babfa80a6a95efb9f75af214 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:06:08 +0300
Subject: [PATCH 091/147] winewayland.drv: Support front buffer rendering in
 window_surface.

Implement a front buffer for window_surface, which, when enabled, is
used as a background image on which window surface contents are drawn
over.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h     |   7 ++
 dlls/winewayland.drv/window.c         |  39 +++++++++
 dlls/winewayland.drv/window_surface.c | 115 +++++++++++++++++++++++++-
 3 files changed, 157 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index eaa6b5605a5..73e12e51351 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -57,6 +57,7 @@ enum wayland_window_message
     WM_WAYLAND_STATE_UPDATE = 0x80001004,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001005,
     WM_WAYLAND_MONITOR_CHANGE = 0x80001006,
+    WM_WAYLAND_WINDOW_SURFACE_FLUSH = 0x80001007,
 };
 
 enum wayland_surface_role
@@ -402,6 +403,9 @@ void wayland_window_surface_set_window_region(struct window_surface *window_surf
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
                                            COLORREF color_key, BYTE alpha,
                                            BOOL src_alpha);
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height));
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -434,6 +438,9 @@ struct opengl_funcs *wayland_get_wgl_driver(UINT version);
 void wayland_update_gl_drawable_surface(HWND hwnd,
                                         struct wayland_surface *wayland_surface);
 void wayland_destroy_gl_drawable(HWND hwnd);
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height));
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 9d849c087dc..f98a4d24e8f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1560,6 +1560,14 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_MONITOR_CHANGE:
         handle_wm_wayland_monitor_change(thread_wayland());
         break;
+    case WM_WAYLAND_WINDOW_SURFACE_FLUSH:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data && data->window_surface)
+                wayland_window_surface_flush(data->window_surface);
+            wayland_win_data_release(data);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
@@ -1589,3 +1597,34 @@ err:
     ERR("Failed to get client rect for hwnd %p", hwnd);
     SetRectEmpty(client_rect);
 }
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+
+        /* Trigger a redraw to apply any front buffer changes. */
+        PostMessageW(hwnd, WM_WAYLAND_WINDOW_SURFACE_FLUSH, 0, 0);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index b4061942104..ef17e711c56 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -51,6 +51,8 @@ struct wayland_window_surface
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
     BITMAPINFO            info;
 };
 
@@ -278,6 +280,28 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         }
     }
 
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * We also damage the whole surface if we just cleared the front buffer
+     * (i.e., front_bits == NULL and front_bits_dirty == TRUE). */
+    if (wws->front_bits || wws->front_bits_dirty)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                SetRectRgn(surface_damage_region,
+                           wws->header.rect.left, wws->header.rect.top,
+                           wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = CreateRectRgnIndirect(&wws->header.rect);
+            }
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -308,6 +332,30 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     }
     buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
+    /* Copy the whole front buffer to wayland SHM buffer. */
+    if (wws->front_bits)
+    {
+        int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+        int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+        int stride = width * 4;
+        unsigned char *src = wws->front_bits;
+        unsigned char *dst = buffer->map_data;
+        int src_stride = wws->info.bmiHeader.biWidth * 4;
+        int dst_stride = buffer->width * 4;
+        int i;
+
+        TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+        /* Front buffer lines are stored bottom to top, so we need to flip
+         * when copying to our buffer. */
+        for (i = 0; i < height; i++)
+        {
+            memcpy(dst + (height - i - 1) * dst_stride,
+                   src + i * src_stride,
+                   stride);
+        }
+    }
+
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
 
@@ -399,7 +447,11 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     heap_free(buffer_damage);
 
 done:
-    if (!wws->last_flush_failed) reset_bounds(&wws->bounds);
+    if (!wws->last_flush_failed)
+    {
+        reset_bounds(&wws->bounds);
+        wws->front_bits_dirty = FALSE;
+    }
     if (surface_damage_region) DeleteObject(surface_damage_region);
     window_surface->funcs->unlock(window_surface);
 }
@@ -421,6 +473,7 @@ static void CDECL wayland_window_surface_destroy(struct window_surface *window_s
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     heap_free(wws->bits);
+    heap_free(wws->front_bits);
     heap_free(wws);
 }
 
@@ -467,6 +520,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->color_key    = color_key;
     wws->alpha        = alpha;
     wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -515,10 +570,16 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
                     get_preferred_format(wws));
     }
-    else if (!wws->wayland_surface && wws->wayland_buffer_queue)
+    else if (!wws->wayland_surface)
     {
-        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
-        wws->wayland_buffer_queue = NULL;
+        if (wws->wayland_buffer_queue)
+        {
+            wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+            wws->wayland_buffer_queue = NULL;
+        }
+        heap_free(wws->front_bits);
+        wws->front_bits = NULL;
+        wws->front_bits_dirty = FALSE;
     }
 
     window_surface->funcs->unlock(window_surface);
@@ -550,3 +611,49 @@ void wayland_window_surface_update_layered(struct window_surface *window_surface
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd=%p front_bits=%p read_pixels=%p size=%dx%d\n",
+          wws->hwnd, wws->front_bits, read_pixels,
+          wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        if (wws->front_bits)
+        {
+            heap_free(wws->front_bits);
+            wws->front_bits = NULL;
+            /* When the front_bits are first invalidated, we mark them as dirty
+             * to force the next window_surface flush. */
+            wws->front_bits_dirty = TRUE;
+        }
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = heap_alloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.34.1

