From 8bddbcefd1c4be14817e3b4ca91e50d83036504f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:34:46 +0300
Subject: [PATCH 080/147] winewayland.drv: Implement wglMakeCurrent and
 wglMakeContextCurrentARB.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 82 +++++++++++++++++++++++++++++++++++
 1 file changed, 82 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 5e7bf539230..fea99664c4b 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -37,6 +37,7 @@
 #include "wine/heap.h"
 
 #include "winuser.h"
+#include "winternl.h"
 
 #include <EGL/egl.h>
 #include <assert.h>
@@ -99,6 +100,7 @@ DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
+DECL_FUNCPTR(eglMakeCurrent);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -168,6 +170,36 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
     if (gl) LeaveCriticalSection(&drawable_section);
 }
 
+static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HWND read_hwnd)
+{
+    BOOL ret;
+    struct wayland_gl_drawable *draw_gl = NULL, *read_gl = NULL;
+
+    draw_gl = wayland_gl_drawable_get(draw_hwnd);
+    read_gl = wayland_gl_drawable_get(read_hwnd);
+
+    TRACE("%p/%p context %p surface %p/%p\n",
+          draw_hwnd, read_hwnd, ctx->context,
+          draw_gl ? draw_gl->surface : NULL,
+          read_gl ? read_gl->surface : NULL);
+
+    ret = p_eglMakeCurrent(egl_display,
+                           draw_gl ? draw_gl->surface : NULL,
+                           read_gl ? read_gl->surface : NULL,
+                           ctx->context);
+    if (ret)
+    {
+        ctx->draw_hwnd = draw_hwnd;
+        ctx->read_hwnd = read_hwnd;
+        NtCurrentTeb()->glContext = ctx;
+    }
+
+    wayland_gl_drawable_release(read_gl);
+    wayland_gl_drawable_release(draw_gl);
+
+    return ret;
+}
+
 static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 {
     TRACE("hwnd=%p\n", gl->hwnd);
@@ -176,6 +208,19 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 
     gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
                                            gl->wayland_surface->glvk->wl_egl_window, NULL);
+    if (gl->surface)
+    {
+        struct wgl_context *ctx;
+
+        wl_list_for_each(ctx, &gl_contexts, link)
+        {
+            if (ctx->draw_hwnd != gl->hwnd && ctx->read_hwnd != gl->hwnd) continue;
+            TRACE("hwnd %p refreshing %p %scurrent\n",
+                  gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
+            if (NtCurrentTeb()->glContext == ctx)
+                wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        }
+    }
 
 out:
     RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
@@ -298,6 +343,37 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     return HeapFree(GetProcessHeap(), 0, ctx);
 }
 
+/***********************************************************************
+ *		wayland_wglMakeContextCurrentARB
+ */
+static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
+                                             struct wgl_context *ctx)
+{
+    BOOL ret = FALSE;
+
+    TRACE("draw_hdc=%p read_hdc=%p ctx=%p\n", draw_hdc, read_hdc, ctx);
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    ret = wgl_context_make_current(ctx, WindowFromDC(draw_hdc), WindowFromDC(read_hdc));
+    if (!ret) SetLastError(ERROR_INVALID_HANDLE);
+
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeCurrent
+ */
+static BOOL WINAPI wayland_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+{
+    return wayland_wglMakeContextCurrentARB(hdc, hdc, ctx);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -417,6 +493,10 @@ static void init_extensions(void)
     register_extension("WGL_WINE_pixel_format_passthrough");
     egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
 
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -795,6 +875,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
+    LOAD_FUNCPTR(eglMakeCurrent);
 #undef LOAD_FUNCPTR
 
     egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
@@ -830,6 +911,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.34.1

