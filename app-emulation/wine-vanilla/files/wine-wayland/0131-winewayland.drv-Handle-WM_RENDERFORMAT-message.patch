From d67cda607999b3961b90d43fcf33053443b6ae37 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:33:25 +0300
Subject: [PATCH 131/147] winewayland.drv: Handle WM_RENDERFORMAT message.

Import into Windows clipboard data we got from other Wayland clients,
for a particular Windows clipboard format. This allow us to fetch
clipboard data and populate the Windows clipboard contents on demand.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 127 +++++++++++++++++++++
 1 file changed, 127 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 295a050e41e..984fd3e8e6e 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -28,6 +28,10 @@
 #include "winuser.h"
 
 #include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
@@ -141,6 +145,98 @@ static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
     heap_free(data_offer);
 }
 
+static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
+                                             const char *mime_type,
+                                             size_t *size_out)
+{
+    int data_pipe[2] = {-1, -1};
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    buffer = heap_alloc(buffer_size);
+    if (buffer == NULL)
+        goto out;
+
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+        goto out;
+
+    wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(data_offer->wayland->wl_display);
+
+    do
+    {
+        struct pollfd pfd = { .fd = data_pipe[0], .events = POLLIN };
+        int ret;
+
+        /* Wait a limited amount of time for the data to arrive, since otherwise
+         * a misbehaving data source could block us indefinitely. */
+        while ((ret = poll(&pfd, 1, 3000)) == -1 && errno == EINTR) continue;
+        if (ret <= 0 || !(pfd.revents & (POLLIN | POLLHUP)))
+        {
+            TRACE("failed polling data offer pipe ret=%d errno=%d revents=0x%x\n",
+                  ret, ret == -1 ? errno : 0, pfd.revents);
+            total = 0;
+            goto out;
+        }
+
+        nread = read(data_pipe[0], buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            ERR("failed to read data offer pipe\n");
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                buffer_size += 4096;
+                buffer = heap_realloc(buffer, buffer_size);
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("received %d bytes\n", total);
+
+out:
+    if (data_pipe[0] >= 0)
+        close(data_pipe[0]);
+
+    if (total == 0 && buffer != NULL)
+    {
+        heap_free(buffer);
+        buffer = NULL;
+    }
+
+    *size_out = total;
+
+    return buffer;
+}
+
+static HGLOBAL wayland_data_offer_import_format(struct wayland_data_offer *data_offer,
+                                                struct wayland_data_device_format *format)
+{
+    size_t data_size;
+    void *data;
+    HGLOBAL mem_handle;
+
+    data = wayland_data_offer_receive_data(data_offer, format->mime_type, &data_size);
+    if (!data)
+        return NULL;
+
+    mem_handle = format->import(format, data, data_size);
+
+    heap_free(data);
+
+    return mem_handle;
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
@@ -363,6 +459,33 @@ static void clipboard_update(void)
     CloseClipboard();
 }
 
+static void clipboard_render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device;
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    data_device = wl_data_device_get_user_data(thread_wayland()->data_device.wl_data_device);
+    if (!data_device->clipboard_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    if (!data_offer)
+        return;
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format && format->clipboard_format == clipboard_format)
+        {
+            HGLOBAL mem_handle = wayland_data_offer_import_format(data_offer, format);
+            SetClipboardData(format->clipboard_format, mem_handle);
+            break;
+        }
+    }
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
@@ -374,6 +497,10 @@ static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM
         /* Ignore our own updates */
         if (GetClipboardOwner() != hwnd) clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        TRACE("WM_RENDERFORMAT: %ld\n", wp);
+        clipboard_render_format(wp);
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
-- 
2.34.1

