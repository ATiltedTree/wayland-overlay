From d42442fb5a4b601d87f89990a61215a9b67fef26 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 10:38:51 +0300
Subject: [PATCH 029/147] winewayland.drv: Create backing Wayland surfaces for
 windows.

Associate Wayland surfaces with windows that need to be displayed by
the native window system. This includes all kinds of top-level windows,
but not child windows, since children are rendered by Wine in the
window surface of their parent top-level.

As a special case, we use Wayland subsurfaces to display windows
that we believe are transient (e.g., popups) and need relative
positioning. We currently use a very simple heuristic to detect such
cases: windows that have an owner but no caption. Future commits
will refine this heuristic.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   9 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          | 175 +++++++++++++++++++++++++
 3 files changed, 185 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12bc68e720c..a2ae525971e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -178,6 +178,11 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
     return data;
 }
 
+static inline struct wayland *thread_init_wayland(void)
+{
+    return &wayland_init_thread_data()->wayland;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
@@ -268,6 +273,10 @@ extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODE
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                           const RECT *window_rect, const RECT *client_rect,
+                                           const RECT *visible_rect, const RECT *valid_rects,
+                                           struct window_surface *surface) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                             const RECT *window_rect, const RECT *client_rect,
                                             RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 0b54723c7a2..1e96be9c972 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -84,6 +84,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index a7a2228097c..e0fad2ceba8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -43,6 +43,12 @@ struct wayland_win_data
     RECT           window_rect;
     /* client area relative to parent */
     RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* whether this window is visible */
+    BOOL           visible;
+    /* whether a wayland surface update is needed */
+    BOOL           wayland_surface_needs_update;
 };
 
 static CRITICAL_SECTION win_data_section;
@@ -69,6 +75,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     heap_free(data);
 
     LeaveCriticalSection(&win_data_section);
@@ -121,6 +128,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
         return NULL;
 
     data->hwnd = hwnd;
+    data->wayland_surface_needs_update = TRUE;
 
     EnterCriticalSection(&win_data_section);
     win_data_context[context_idx(hwnd)] = data;
@@ -130,6 +138,150 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
     return data;
 }
 
+/***********************************************************************
+ *           wayland_surface_for_hwnd_lock
+ *
+ *  Gets the wayland surface for HWND while locking the private window data.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+
+    if (data && data->wayland_surface)
+        return data->wayland_surface;
+
+    wayland_win_data_release(data);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlock
+ */
+static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+{
+    if (surface) LeaveCriticalSection(&win_data_section);
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_update)
+        return TRUE;
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct wayland_surface *update_surface_for_role(struct wayland_win_data *data,
+                                                       enum wayland_surface_role role,
+                                                       struct wayland *wayland,
+                                                       struct wayland_surface *parent_surface)
+{
+    struct wayland_surface *surface = data->wayland_surface;
+
+    if (!surface ||
+        (role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != role))
+    {
+        surface = wayland_surface_create_plain(wayland);
+        if (surface) EnterCriticalSection(&surface->crit);
+    }
+    else
+    {
+        /* Lock the wayland surface to avoid other threads interacting with it
+         * while we are updating. */
+        EnterCriticalSection(&surface->crit);
+        wayland_surface_clear_role(surface);
+        /* Clear the associated HWND, to allow a potential invocation of
+         * wayland_surface_make_toplevel below, to properly handle the
+         * initial configure event. */
+        surface->hwnd = 0;
+    }
+
+    if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
+        wayland_surface_make_toplevel(surface, parent_surface);
+    else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        wayland_surface_make_subsurface(surface, parent_surface);
+
+    surface->hwnd = data->hwnd;
+
+    LeaveCriticalSection(&surface->crit);
+
+    return surface;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland;
+    HWND effective_parent_hwnd;
+    struct wayland_surface *surface;
+    struct wayland_surface *parent_surface;
+    DWORD style;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_update = FALSE;
+
+    wayland = thread_init_wayland();
+
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    effective_parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+    {
+        parent_surface = wayland_surface_for_hwnd_lock(effective_parent_hwnd);
+        wayland_surface_for_hwnd_unlock(parent_surface);
+    }
+
+    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Use wayland subsurfaces for children windows and windows that are
+     * transient (i.e., don't have a titlebar). Otherwise, if the window is
+     * visible make it wayland toplevel. Finally, if the window is not visible
+     * create a plain (without a role) surface to avoid polluting the
+     * compositor with empty xdg_toplevels. */
+    if ((style & WS_CAPTION) != WS_CAPTION)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
+                                          wayland, parent_surface);
+    }
+    else if (data->visible)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_TOPLEVEL,
+                                          wayland, parent_surface);
+    }
+    else
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_NONE,
+                                          wayland, parent_surface);
+    }
+
+    if (data->wayland_surface != surface)
+    {
+        if (data->wayland_surface)
+            wayland_surface_unref(data->wayland_surface);
+        data->wayland_surface = surface;
+    }
+}
+
+static void update_wayland_state(struct wayland_win_data *data)
+{
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -181,11 +333,34 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
     wayland_win_data_release(data);
     return TRUE;
 }
 
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                    const RECT *window_rect, const RECT *client_rect,
+                                    const RECT *visible_rect, const RECT *valid_rects,
+                                    struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), GetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    update_wayland_state(data);
+
+    wayland_win_data_release(data);
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
-- 
2.34.1

