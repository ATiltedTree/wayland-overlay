From 502e8e3c215acdcbd4402dc0433694637e4d54a3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:53:51 +0300
Subject: [PATCH 007/147] winewayland.drv: Initialize basic per-thread Wayland
 instance.

Every thread that requires interaction with Wayland maintains its own
independent set of Wayland protocols objects. Events from Wayland
protocol objects are dispatched into a thread-specific Wayland event
queue.

This design simplifies synchronization, since there is no shared Wayland
state between threads, and will later make it easier to dispatch events
to the proper thread message queue. The downside is that there is some
duplication of event handling if multiple GUI threads are present.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 105 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |  18 +++++
 dlls/winewayland.drv/waylanddrv_main.c |  10 +++
 3 files changed, 132 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1a12d4fb9a4..c81a220ee27 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -22,8 +22,112 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
 struct wl_display *process_wl_display = NULL;
 
+/**********************************************************************
+ *          Registry handling
+ */
+
+static void registry_handle_global(void *data, struct wl_registry *registry,
+                                   uint32_t id, const char *interface,
+                                   uint32_t version)
+{
+    struct wayland *wayland = data;
+
+    TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
+
+    if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
+}
+
+static void registry_handle_global_remove(void *data, struct wl_registry *registry,
+                                          uint32_t id)
+{
+    TRACE("id=%d\n", id);
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+
+/**********************************************************************
+ *          wayland_init
+ *
+ *  Initialise a wayland instance.
+ */
+BOOL wayland_init(struct wayland *wayland)
+{
+    TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
+
+    wayland->process_id = GetCurrentProcessId();
+    wayland->thread_id = GetCurrentThreadId();
+    wayland->wl_display = process_wl_display;
+
+    if (!wayland->wl_display)
+    {
+        ERR("Failed to connect to wayland compositor\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create event queue\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_registry = wl_display_get_registry(wayland->wl_display)))
+    {
+        ERR("Failed to get to wayland registry\n");
+        return FALSE;
+    }
+    wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
+
+    /* Populate registry */
+    wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
+
+    /* We need three roundtrips. One to get and bind globals, one to handle all
+     * initial events produced from registering the globals and one more to
+     * handle potential third-order registrations. */
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
+    wayland->initialized = TRUE;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_deinit
+ *
+ *  Deinitialise a wayland instance, releasing all associated resources.
+ */
+void wayland_deinit(struct wayland *wayland)
+{
+    TRACE("%p\n", wayland);
+
+    if (wayland->wl_compositor)
+        wl_compositor_destroy(wayland->wl_compositor);
+
+    if (wayland->wl_registry)
+        wl_registry_destroy(wayland->wl_registry);
+
+    if (wayland->wl_event_queue)
+        wl_event_queue_destroy(wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    memset(wayland, 0, sizeof(*wayland));
+}
+
 /**********************************************************************
  *          wayland_process_init
  *
@@ -35,4 +139,3 @@ BOOL wayland_process_init(void)
     process_wl_display = wl_display_connect(NULL);
     return process_wl_display != NULL;
 }
-
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4e6a39aaf10..9728811c313 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -33,12 +33,28 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+ *          Definitions for wayland types
+ */
+
+struct wayland
+{
+    BOOL initialized;
+    DWORD process_id;
+    DWORD thread_id;
+    struct wl_display *wl_display;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_registry *wl_registry;
+    struct wl_compositor *wl_compositor;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
 
 struct wayland_thread_data
 {
+    struct wayland wayland;
 };
 
 extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
@@ -57,5 +73,7 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
  */
 
 BOOL wayland_process_init(void);
+BOOL wayland_init(struct wayland *wayland);
+void wayland_deinit(struct wayland *wayland);
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1ff07ceefc8..905d1000c2d 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -29,6 +29,7 @@
 #include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 
@@ -47,6 +48,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    if (!wayland_init(&data->wayland))
+    {
+        ERR_(winediag)("waylanddrv: Can't open wayland display. Please ensure "
+                       "that your wayland server is running and that "
+                       "$WAYLAND_DISPLAY is set correctly.\n");
+        ExitProcess(1);
+    }
+
     TlsSetValue(thread_data_tls_index, data);
 
     return data;
@@ -61,6 +70,7 @@ static void CDECL WAYLAND_ThreadDetach(void)
 
     if (data)
     {
+        wayland_deinit(&data->wayland);
         heap_free(data);
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
         TlsSetValue(thread_data_tls_index, NULL);
-- 
2.34.1

