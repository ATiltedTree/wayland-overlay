From fe1f13b03e2ac389402d2a333ae054318391c327 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 13:45:18 +0300
Subject: [PATCH 065/147] winewayland.drv: Implement Wine monitor change
 notification.

Introduce a mechanism to synchronously notify all Wayland capable
threads about changes in the current Wine monitor setup.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c        | 32 +++++++++++++++++++++
 dlls/winewayland.drv/wayland_output.c | 41 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  6 ++++
 dlls/winewayland.drv/window.c         | 24 ++++++++++++++++
 4 files changed, 103 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 70690ff4b20..c90397da9dc 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -594,3 +594,35 @@ DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handl
 
     return ret;
 }
+
+/**********************************************************************
+ *          wayland_notify_wine_monitor_change
+ *
+ * Notify all wayland instances about a change in the state of wine monitors.
+ * The notification is synchronous, this function returns after all wayland
+ * instances have handled the event, except if it a thread is slow to process
+ * the message, and thus likely to be blocked by this synchronous operation.
+ */
+void wayland_notify_wine_monitor_change(void)
+{
+    struct wayland *w;
+
+    EnterCriticalSection(&thread_wayland_section);
+
+    /* Each thread maintains its own output mode information, so we need to
+     * notify all threads about the wine mode change. We can't guarantee that
+     * all threads will have windows to which we could potentially send the
+     * notification message to, so we use the internal send function to target
+     * the threads directly. We can't use PostThreadMessage since we require
+     * synchronous message handling. */
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        /* Use a timeout of 50ms to avoid blocking indefinitely if the
+         * target thread is not processing (and to avoid deadlocks). */
+        __wine_send_internal_message_timeout(w->process_id, w->thread_id,
+                                             WM_WAYLAND_MONITOR_CHANGE,
+                                             0, 0, 0, 50, NULL);
+    }
+
+    LeaveCriticalSection(&thread_wayland_section);
+}
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 91679975af0..9e026a0d555 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -524,6 +524,9 @@ void wayland_update_outputs_from_process(struct wayland *wayland)
             if (!strcmp(output->name, process_output->name))
             {
                 lstrcpyW(output->wine_name, process_output->wine_name);
+                wayland_output_set_wine_mode(output,
+                                             process_output->current_wine_mode->width,
+                                             process_output->current_wine_mode->height);
                 break;
             }
         }
@@ -551,3 +554,41 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
     return NULL;
 }
+
+/**********************************************************************
+ *          wayland_output_set_wine_mode
+ *
+ * Set the current wine mode for the specified output.
+ */
+void wayland_output_set_wine_mode(struct wayland_output *output, int width, int height)
+{
+    struct wayland_output_mode *output_mode;
+
+    TRACE("output->name=%s width=%d height=%d\n", output->name, width, height);
+
+    /* We always use 32bpp modes since that's the only one we really
+     * support. */
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (output_mode->width == width && output_mode->height == height &&
+            output_mode->bpp == 32)
+        {
+            output->current_wine_mode = output_mode;
+            break;
+        }
+    }
+
+    if (!output->current_wine_mode || !output->current_mode)
+    {
+        output->wine_scale = 1.0;
+    }
+    else
+    {
+        double scale_x = ((double)output->current_mode->width) /
+                         output->current_wine_mode->width;
+        double scale_y = ((double)output->current_mode->height) /
+                         output->current_wine_mode->height;
+        /* We want to keep the aspect ratio of the target mode. */
+        output->wine_scale = fmin(scale_x, scale_y);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5e0684dceba..8eb9db81384 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -54,6 +54,7 @@ enum wayland_window_message
     WM_WAYLAND_CONFIGURE = 0x80001003,
     WM_WAYLAND_STATE_UPDATE = 0x80001004,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001005,
+    WM_WAYLAND_MONITOR_CHANGE = 0x80001006,
 };
 
 enum wayland_surface_role
@@ -286,6 +287,11 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
 void wayland_update_outputs_from_process(struct wayland *wayland);
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name);
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland,
+                                                uint32_t id);
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  int width, int height);
+void wayland_notify_wine_monitor_change(void);
 
 /**********************************************************************
  *          Wayland event dispatch
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cf43501388e..ba14fc747f8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1451,6 +1451,27 @@ out:
     wayland_surface_for_hwnd_unlock(wsurface);
 }
 
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+    struct wayland_surface *surface, *tmp;
+
+    wayland_update_outputs_from_process(wayland);
+
+    /* Update the state of all surfaces tracked by the wayland thread instance,
+     * in case any surface was affected by the monitor changes (e.g., gained or
+     * lost the fullscreen state). We use the safe iteration variant since a
+     * state update may cause the surface to be recreated. */
+    wl_list_for_each_safe(surface, tmp, &wayland->toplevel_list, link)
+    {
+        struct wayland_win_data *data = wayland_win_data_get(surface->hwnd);
+        if (data)
+        {
+            update_wayland_state(data);
+            wayland_win_data_release(data);
+        }
+    }
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
@@ -1521,6 +1542,9 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
         handle_wm_wayland_surface_output_change(hwnd);
         break;
+    case WM_WAYLAND_MONITOR_CHANGE:
+        handle_wm_wayland_monitor_change(thread_wayland());
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1

