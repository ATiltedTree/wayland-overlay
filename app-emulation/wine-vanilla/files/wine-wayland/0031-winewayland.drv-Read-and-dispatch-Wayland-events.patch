From e6ba2fcdba131dd4402abbea57758bf0ed91a66e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 14:37:22 +0300
Subject: [PATCH 031/147] winewayland.drv: Read and dispatch Wayland events.

Create a separate reader thread to read Wayland events from the compositor
and dispatch them to their appropriate queues. The reader thread
notifies all Wayland-enabled threads of possible new events by using
an unnamed pipe for each thread. The read end of the pipe is
used as the Wine driver queue fd for the respective thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 133 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |  48 +++++++++
 3 files changed, 184 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 385ac73575c..3d5fe2c69d5 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -25,6 +25,11 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <unistd.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
@@ -40,6 +45,17 @@ static CRITICAL_SECTION_DEBUG process_wayland_critsect_debug =
 CRITICAL_SECTION process_wayland_section = { &process_wayland_critsect_debug,
                                              -1, 0, 0, 0, 0 };
 
+static CRITICAL_SECTION thread_wayland_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &thread_wayland_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": thread_wayland_section") }
+};
+static CRITICAL_SECTION thread_wayland_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
+
 /**********************************************************************
  *          xdg_wm_base handling
  */
@@ -141,8 +157,14 @@ static const struct wl_registry_listener registry_listener = {
  */
 BOOL wayland_init(struct wayland *wayland)
 {
+    int flags;
+
     TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
 
+    wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
+
     wayland->process_id = GetCurrentProcessId();
     wayland->thread_id = GetCurrentThreadId();
     wayland->wl_display = process_wl_display;
@@ -184,6 +206,24 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
 
+    if (!wayland_is_process(wayland))
+    {
+        /* Thread wayland instances have notification pipes to inform them when
+         * there might be new events in their queues. The read part of the pipe
+         * is also used as the wine server queue fd. */
+        if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+            return FALSE;
+        /* Make just the read end non-blocking */
+        if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+            return FALSE;
+        if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+            return FALSE;
+        /* Keep a list of all thread wayland instances, so we can notify them. */
+        EnterCriticalSection(&thread_wayland_section);
+        wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+        LeaveCriticalSection(&thread_wayland_section);
+    }
+
     wayland->initialized = TRUE;
 
     return TRUE;
@@ -200,6 +240,15 @@ void wayland_deinit(struct wayland *wayland)
 
     TRACE("%p\n", wayland);
 
+    EnterCriticalSection(&thread_wayland_section);
+    wl_list_remove(&wayland->thread_link);
+    LeaveCriticalSection(&thread_wayland_section);
+
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
@@ -301,3 +350,87 @@ int wayland_dispatch_buffer(struct wayland *wayland)
     return wl_display_dispatch_queue_pending(wayland->wl_display,
                                              wayland->buffer_wl_event_queue);
 }
+
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    EnterCriticalSection(&thread_wayland_section);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    LeaveCriticalSection(&thread_wayland_section);
+}
+
+/**********************************************************************
+ *          wayland_read_events
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues and notify threads about the possibility of new events.
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events(void)
+{
+    struct pollfd pfd = {0};
+    int ret;
+
+    pfd.fd = wl_display_get_fd(process_wl_display);
+    pfd.events = POLLIN;
+
+    TRACE("waiting for events...\n");
+
+    /* In order to read events we need to prepare the read on some
+     * queue. We can safely use the default queue, since it's
+     * otherwise unused (all struct wayland instances dispatch to
+     * their own queues). */
+    while (wl_display_prepare_read(process_wl_display) != 0)
+    {
+        if (wl_display_dispatch_pending(process_wl_display) == -1)
+        {
+            TRACE("... failed wl_display_dispatch_pending errno=%d\n", errno);
+            return FALSE;
+        }
+    }
+
+    wl_display_flush(process_wl_display);
+
+    while ((ret = poll(&pfd, 1, -1)) == -1 && errno == EINTR) continue;
+
+    if (ret == -1 || !(pfd.revents & POLLIN))
+    {
+        TRACE("... failed poll errno=%d revents=0x%x\n",
+              ret == -1 ? errno : 0, pfd.revents);
+        wl_display_cancel_read(process_wl_display);
+        return FALSE;
+    }
+
+    if (wl_display_read_events(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_read_events errno=%d\n", errno);
+        return FALSE;
+    }
+
+    if (wl_display_dispatch_pending(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_dispatch_pending errno=%d\n", errno);
+        return FALSE;
+    }
+
+    wayland_notify_threads();
+
+    TRACE("... done\n");
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 03e2b13acd7..a3cde85999b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -82,6 +82,8 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    int event_notification_pipe[2];
+    struct wl_list thread_link;
 };
 
 struct wayland_output_mode
@@ -211,6 +213,7 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 int wayland_dispatch_buffer(struct wayland *wayland);
+BOOL wayland_read_events(void);
 
 /**********************************************************************
  *          Wayland buffer queue
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1e96be9c972..cf0b6bcbd4f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -26,12 +26,54 @@
 
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 
+static DWORD WINAPI wayland_read_thread(void *arg)
+{
+    while (wayland_read_events()) continue;
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    exit(1);
+    return 0;
+}
+
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        ExitProcess(1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        ExitProcess(1);
+    }
+
+    CloseHandle(handle);
+}
+
 /***********************************************************************
  *           Initialize per thread data
  */
@@ -55,6 +97,7 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    set_queue_fd(&data->wayland);
     TlsSetValue(thread_data_tls_index, data);
 
     return data;
@@ -93,12 +136,17 @@ static const struct user_driver_funcs waylanddrv_funcs =
  */
 static BOOL process_attach(void)
 {
+    DWORD id;
+
     if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
 
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
     if (!wayland_process_init()) return FALSE;
 
+    /* All reads of wayland events happen from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_thread, NULL, 0, &id);
+
     return TRUE;
 }
 
-- 
2.34.1

