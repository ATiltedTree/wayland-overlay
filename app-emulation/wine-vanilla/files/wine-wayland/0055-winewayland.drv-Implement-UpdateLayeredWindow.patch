From 3eb8f7ca2bdf08bcb333146cf7f4d480cbed8374 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 14:39:51 +0300
Subject: [PATCH 055/147] winewayland.drv: Implement UpdateLayeredWindow.

Support per-pixel alpha values and background blending.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |  9 ++-
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 98 +++++++++++++++++++++++++-
 dlls/winewayland.drv/window_surface.c  | 39 +++++++---
 4 files changed, 132 insertions(+), 15 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1473eeaef99..ca32bb73981 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -35,6 +35,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "wingdi.h"
+#include "winuser.h"
 
 #include "wine/gdi_driver.h"
 
@@ -339,7 +340,8 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
  */
 
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha);
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha);
 void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
@@ -347,7 +349,8 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region);
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha);
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha);
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -399,6 +402,8 @@ extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                                      LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                              const RECT *window_rect) DECLSPEC_HIDDEN;
 extern SHORT CDECL WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index f5d9adae6ab..34d6a7e3f34 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -134,6 +134,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pUpdateLayeredWindow = WAYLAND_UpdateLayeredWindow,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cb7be660a4f..68e678ce6ea 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -919,7 +919,7 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
     if (!(flags & LWA_ALPHA)) alpha = 255;
 
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
 
 done:
     wayland_win_data_release(data);
@@ -1014,7 +1014,7 @@ void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     {
         TRACE("hwnd=%p changed layered\n", hwnd);
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
     }
 
     wayland_win_data_release(data);
@@ -1035,11 +1035,103 @@ void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alph
     if ((data = wayland_win_data_get(hwnd)))
     {
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
         wayland_win_data_release(data);
     }
 }
 
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL CDECL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                       const RECT *window_rect)
+{
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, info->crKey, wine_dbgstr_rect(info->prcDirty), info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = CreateDIBSection(info->hdcDst, bmi, DIB_RGB_COLORS, &src_bits, NULL, 0))) goto done;
+    if (!(hdc = CreateCompatibleDC(0))) goto done;
+
+    SelectObject(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        IntersectRect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    DPtoLP(info->hdcSrc, (POINT *)&src_rect, 2);
+
+    ret = GdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                        info->hdcSrc, src_rect.left, src_rect.top,
+                        src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                        (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        UnionRect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) DeleteDC(hdc);
+    if (dib) DeleteObject(dib);
+    return ret;
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index ef3e86ea53d..b4061942104 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -47,6 +47,7 @@ struct wayland_window_surface
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
     COLORREF              color_key;
     BYTE                  alpha;
+    BOOL                  src_alpha;
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
@@ -87,7 +88,7 @@ static int get_preferred_format(struct wayland_window_surface *wws)
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
     if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR) ||
-        wws->color_key != CLR_INVALID || wws->alpha != 255)
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -289,9 +290,9 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     if (!needs_flush) goto done;
 
     TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
-          "alpha %02x compression %d region %p\n",
+          "alpha %02x src_alpha %d compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->color_key, wws->alpha,
+          wws->bits, wws->color_key, wws->alpha, wws->src_alpha,
           wws->info.bmiHeader.biCompression,
           wws->total_region);
 
@@ -332,8 +333,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha to ensure the destination has sensible alpha values. */
-        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+         * alpha to ensure the destination has sensible alpha values. The
+         * exception is when the surface uses source alpha values and the
+         * surface alpha is 255, in which case we can just copy pixel values
+         * as they are. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                              (wws->alpha != 255 || !wws->src_alpha);
 
         /* Fast path for full width rectangles. */
         if (width == buffer->width && !apply_surface_alpha &&
@@ -349,12 +354,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else if (wws->alpha == 255)
+            else if (wws->alpha == 255 && !wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
-            else
+            else if (!wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                 {
@@ -364,6 +369,16 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
                               (((BYTE)src[x] * wws->alpha / 255)));
                 }
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
 
             if (wws->color_key != CLR_INVALID)
                 for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
@@ -424,7 +439,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
  *           wayland_window_surface_create
  */
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha)
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -450,6 +466,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->hwnd         = hwnd;
     wws->color_key    = color_key;
     wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -511,17 +528,19 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
  *           wayland_window_surface_update_layered
  */
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha)
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
 
     window_surface->funcs->lock(window_surface);
 
-    if (alpha != wws->alpha || color_key != wws->color_key)
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
         *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
 
     wws->alpha = alpha;
     wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
 
     if (wws->wayland_buffer_queue &&
         wws->wayland_buffer_queue->format != get_preferred_format(wws))
-- 
2.34.1

