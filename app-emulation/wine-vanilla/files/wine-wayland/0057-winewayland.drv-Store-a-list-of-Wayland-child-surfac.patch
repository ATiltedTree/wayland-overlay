From ad9338d1136d42aa0532f716e70e790a2c761188 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 15:38:48 +0300
Subject: [PATCH 057/147] winewayland.drv: Store a list of Wayland child
 surfaces.

Make each Wayland surfaces aware of its subsurfaces, and also maintain a
list of toplevel surfaces. This will allow us to efficiently apply
property changes (e.g., changing the output associated with a surface)
to whole surface tree hierarchies in upcoming commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |  5 +++
 dlls/winewayland.drv/wayland_surface.c | 52 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 ++
 3 files changed, 60 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 421142b92c1..593e88b675f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -240,6 +240,7 @@ BOOL wayland_init(struct wayland *wayland)
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
     wl_list_init(&wayland->output_list);
+    wl_list_init(&wayland->toplevel_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -282,6 +283,7 @@ BOOL wayland_init(struct wayland *wayland)
 void wayland_deinit(struct wayland *wayland)
 {
     struct wayland_output *output, *output_tmp;
+    struct wayland_surface *toplevel, *toplevel_tmp;
 
     TRACE("%p\n", wayland);
 
@@ -289,6 +291,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     LeaveCriticalSection(&thread_wayland_section);
 
+    wl_list_for_each_safe(toplevel, toplevel_tmp, &wayland->toplevel_list, link)
+        wayland_surface_destroy(toplevel);
+
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
     if (wayland->event_notification_pipe[1] >= 0)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 72b95c0d148..f6ea816b3b0 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -153,6 +153,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->link);
+    wl_list_init(&surface->child_list);
     wl_surface_set_user_data(surface->wl_surface, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
@@ -160,6 +162,10 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
 
+    /* Although not technically toplevel, plain surfaces have no parent, so
+     * track them in the toplevel list. */
+    wl_list_insert(&wayland->toplevel_list, &surface->link);
+
     return surface;
 
 err:
@@ -197,6 +203,9 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
 
+    /* Plain surfaces (which are the only kind can become toplevel) are
+     * already tracked in the toplevel_list, there is no need to readd. */
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
@@ -232,6 +241,14 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     surface->drawing_allowed = TRUE;
 
     surface->parent = wayland_surface_ref(parent);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&surface->link);
+    EnterCriticalSection(&parent->crit);
+    wl_list_insert(&parent->child_list, &surface->link);
+    LeaveCriticalSection(&parent->crit);
+
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
                                         surface->wl_surface,
@@ -265,6 +282,18 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 
     surface->drawing_allowed = FALSE;
 
+    if (surface->parent)
+    {
+        /* As a plain surface, this should now tracked in the toplevel_list. */
+        EnterCriticalSection(&surface->parent->crit);
+        wl_list_remove(&surface->link);
+        LeaveCriticalSection(&surface->parent->crit);
+        wl_list_insert(&surface->wayland->toplevel_list, &surface->link);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -515,6 +544,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_surface *child, *child_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -524,6 +554,20 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (keyboard->focused_surface == surface)
         keyboard->focused_surface = NULL;
 
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    EnterCriticalSection(&surface->crit);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, link)
+    {
+        /* Since the current surface (the parent) is being destroyed,
+         * disassociate from the child to avoid the child trying to
+         * destroy the parent. */
+        child->parent = NULL;
+        wayland_surface_destroy(child);
+    }
+    LeaveCriticalSection(&surface->crit);
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -550,9 +594,17 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     if (surface->parent)
     {
+        EnterCriticalSection(&surface->parent->crit);
+        wl_list_remove(&surface->link);
+        LeaveCriticalSection(&surface->parent->crit);
+
         wayland_surface_unref(surface->parent);
         surface->parent = NULL;
     }
+    else
+    {
+        wl_list_remove(&surface->link);
+    }
 
     surface->crit.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&surface->crit);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1380412282c..801d20f70fa 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -126,6 +126,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wl_list toplevel_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
@@ -173,6 +174,7 @@ struct wayland_surface_configure
 
 struct wayland_surface
 {
+    struct wl_list link;
     struct wayland *wayland;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
@@ -187,6 +189,7 @@ struct wayland_surface
     LONG ref;
     enum wayland_surface_role role;
     BOOL drawing_allowed;
+    struct wl_list child_list;
 };
 
 struct wayland_buffer_queue
-- 
2.34.1

