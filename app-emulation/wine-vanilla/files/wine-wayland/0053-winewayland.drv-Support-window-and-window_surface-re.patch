From b07c255c02e009e2f9696ee9ac9d6c793946c49f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 15:53:46 +0300
Subject: [PATCH 053/147] winewayland.drv: Support window and window_surface
 regions.

Use buffers with an alpha channel (ARGB8888) to implement window
regions. Pixels outside the region are left as transparent in the
buffer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  17 +++
 dlls/winewayland.drv/window_surface.c  | 168 +++++++++++++++++++++++--
 4 files changed, 179 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4243df13e10..a3a05831218 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -343,6 +343,8 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region);
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -385,6 +387,7 @@ extern UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECL
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 extern UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 99bf1f3fa1b..8305ace1b61 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -128,6 +128,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetWindowRgn = WAYLAND_SetWindowRgn,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e28e211eb0f..3728db3cb1e 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -968,6 +968,23 @@ UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index b61d5bc0489..b39bb0984db 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -43,6 +43,8 @@ struct wayland_window_surface
     struct wayland_surface *wayland_surface; /* Not owned by us */
     struct wayland_buffer_queue *wayland_buffer_queue;
     RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
@@ -72,6 +74,104 @@ static inline void reset_bounds(RECT *bounds)
     bounds->right = bounds->bottom = INT_MIN;
 }
 
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = CreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR))
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) DeleteObject(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue || !wws->wayland_surface) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = CreateRectRgn(0, 0, 0, 0);
+        if (region && GetWindowRgn(wws->hwnd, region) == ERROR)
+        {
+            DeleteObject(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = CreateRectRgn(0, 0, 0, 0);
+        if (region) CombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            CombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = CreateRectRgn(0, 0, 0, 0);
+            if (region) CombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) DeleteObject(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
 /***********************************************************************
  *           wayland_window_surface_lock
  */
@@ -118,7 +218,23 @@ static RECT CDECL *wayland_window_surface_get_bounds(struct window_surface *wind
 static void CDECL wayland_window_surface_set_region(struct window_surface *window_surface,
                                                     HRGN region)
 {
-    /* TODO */
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) DeleteObject(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = CreateRectRgn(0, 0, 0, 0);
+        CombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
 }
 
 /***********************************************************************
@@ -141,6 +257,23 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
           wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
 
     needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        RECT total_region_box;
+        surface_damage_region = CreateRectRgnIndirect(&damage_rect);
+        /* If the total_region is empty we are guaranteed to have empty SHM
+         * buffers. In order for this empty content to take effect, we still
+         * need to commit with non-empty damage, so don't AND with the
+         * total_region in this case, to ensure we don't end up with an empty
+         * surface_damage_region. */
+        if (wws->total_region &&
+            GetRgnBox(wws->total_region, &total_region_box) != NULLREGION)
+        {
+            needs_flush = CombineRgn(surface_damage_region, surface_damage_region,
+                                     wws->total_region, RGN_AND);
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -152,11 +285,9 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
     if (!needs_flush) goto done;
 
-    surface_damage_region = CreateRectRgnIndirect(&damage_rect);
-
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits);
+          wws->bits, wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -168,7 +299,7 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         wws->last_flush_failed = TRUE;
         goto done;
     }
-    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
@@ -177,7 +308,8 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     for (;rgn_rect < rgn_rect_end; rgn_rect++)
     {
         unsigned int *src, *dst;
-        int y, width, height;
+        int x, y, width, height;
+        BOOL apply_surface_alpha;
 
         TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
 
@@ -193,8 +325,13 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
+        /* If we have an ARGB buffer we need to explicitly apply the surface
+         * alpha (assumed to be 255 currently) to ensure the destination has
+         * sensible alpha values. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+
         /* Fast path for full width rectangles. */
-        if (width == buffer->width)
+        if (width == buffer->width && !apply_surface_alpha)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -202,7 +339,15 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
         for (y = 0; y < height; y++)
         {
-            memcpy(dst, src, width * 4);
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -236,6 +381,8 @@ static void CDECL wayland_window_surface_destroy(struct window_surface *window_s
 
     wws->crit.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&wws->crit);
+    if (wws->region) DeleteObject(wws->region);
+    if (wws->total_region) DeleteObject(wws->total_region);
     if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
@@ -281,6 +428,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
     if (!(wws->bits = heap_alloc(wws->info.bmiHeader.biSizeImage)))
@@ -326,7 +474,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
         wws->wayland_buffer_queue =
             wayland_buffer_queue_create(wws->wayland_surface->wayland,
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
-                    WL_SHM_FORMAT_XRGB8888);
+                    get_preferred_format(wws));
     }
     else if (!wws->wayland_surface && wws->wayland_buffer_queue)
     {
-- 
2.34.1

